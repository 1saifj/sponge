package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/zhufuyi/sponge/cmd/protoc-gen-go-gin/internal/generate/handler"
	"github.com/zhufuyi/sponge/cmd/protoc-gen-go-gin/internal/generate/router"
	"github.com/zhufuyi/sponge/cmd/protoc-gen-go-gin/internal/generate/service"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	handlerPlugin = "handler"
	servicePlugin = "service"

	exampleTip = `
# generate *_router.pb.go file
protoc --proto_path=. --proto_path=./third_party --go-gin_out=. --go-gin_opt=paths=source_relative *.proto

# generate *_router.pb.go, *_handler.go, *_logic.go files
protoc --proto_path=. --proto_path=./third_party --go-gin_out=. --go-gin_opt=paths=source_relative --go-gin_opt=plugin=handler \
  --go-gin_opt=moduleName=yourModuleName --go-gin_opt=serverName=yourServerName *.proto

# generate *_router.pb.go, *_service.go, *_logic.go files
protoc --proto_path=. --proto_path=./third_party --go-gin_out=. --go-gin_opt=paths=source_relative --go-gin_opt=plugin=service \
  --go-gin_opt=moduleName=yourModuleName --go-gin_opt=serverName=yourServerName *.proto
`

	optErrFormat = `--go-gin_opt error, '%s' cannot be empty.

Usage example: 
    protoc --proto_path=. --proto_path=./third_party \
      --go-gin_out=. --go-gin_opt=paths=source_relative \
      --go-gin_opt=plugin=%s --go-gin_opt=moduleName=yourModuleName --go-gin_opt=serverName=yourServerName \
      *.proto
`
)

func main() {
	var example bool
	flag.BoolVar(&example, "example", false, "usage example")
	flag.Parse()
	if example {
		fmt.Printf("%s", exampleTip)
		return
	}

	var flags flag.FlagSet

	var plugin, moduleName, serverName, tmplOut, routerOut string
	flags.StringVar(&plugin, "plugin", "", "plugin name, supported values: handler or service")
	flags.StringVar(&moduleName, "moduleName", "", "module name for plugin")
	flags.StringVar(&serverName, "serverName", "", "server name for plugin")
	flags.StringVar(&tmplOut, "tmplOut", "", "folder of logical template codes generated by the plugin"+
		"the default value is internal/handler if the plugin is a handler, or internal/service if it is a service")
	flags.StringVar(&routerOut, "routerOut", "", "folder of routing codes generated by the plugin, default is internal/routers")

	options := protogen.Options{
		ParamFunc: flags.Set,
	}

	options.Run(func(gen *protogen.Plugin) error {
		handlerFlag, serviceFlag := false, false
		pluginName := strings.ReplaceAll(plugin, " ", "")
		switch pluginName {
		case handlerPlugin:
			handlerFlag = true
			if tmplOut == "" {
				tmplOut = "internal/handler"
			}
			if routerOut == "" {
				routerOut = "internal/routers"
			}
		case servicePlugin:
			serviceFlag = true
			if tmplOut == "" {
				tmplOut = "internal/service"
			}
			if routerOut == "" {
				routerOut = "internal/routers"
			}
		case "":
		default:
			return fmt.Errorf("protoc-gen-go-gin: unknown plugin %q", plugin)
		}

		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			router.GenerateFile(gen, f)

			if handlerFlag {
				err := saveHandlerAndRouterFiles(gen, f, moduleName, serverName, tmplOut, routerOut)
				if err != nil {
					continue // skip error, process the next protobuf file
				}
			} else if serviceFlag {
				err := saveServiceAndRouterFiles(gen, f, moduleName, serverName, tmplOut, routerOut)
				if err != nil {
					continue // skip error, process the next protobuf file
				}
			}
		}
		return nil
	})
}

func saveHandlerAndRouterFiles(gen *protogen.Plugin, f *protogen.File, moduleName string, serverName string, tmplOut string, routerOut string) error {
	filename, routerContent, gf := handler.GenerateFile(gen, f)
	if gf == nil {
		return nil
	}

	content, err := gf.Content()
	if err != nil {
		return err
	}

	err = saveFile(moduleName, serverName, tmplOut, filename, content, false, handlerPlugin)
	if err != nil {
		return err
	}

	err = saveFile(moduleName, serverName, routerOut, filename, routerContent, true, handlerPlugin)
	if err != nil {
		return err
	}

	gf.Skip()
	return nil
}

func saveServiceAndRouterFiles(gen *protogen.Plugin, f *protogen.File, moduleName string, serverName string, tmplOut string, routerOut string) error {
	filename, routerContent, gf := service.GenerateFile(gen, f)
	if gf == nil {
		return nil
	}

	content, err := gf.Content()
	if err != nil {
		return err
	}

	err = saveFile(moduleName, serverName, tmplOut, filename, content, false, servicePlugin)
	if err != nil {
		return err
	}

	err = saveFile(moduleName, serverName, routerOut, filename, routerContent, true, servicePlugin)
	if err != nil {
		return err
	}

	gf.Skip()
	return nil
}

func saveFile(moduleName string, serverName string, out string, filename string, content []byte, isNeedCovered bool, pluginName string) error {
	if moduleName == "" {
		panic(fmt.Sprintf(optErrFormat, "moduleName", pluginName))
	}
	if serverName == "" {
		panic(fmt.Sprintf(optErrFormat, "serverName", pluginName))
	}

	_ = os.MkdirAll(out, 0666)
	_, name := filepath.Split(filename)
	if isNeedCovered {
		name = strings.ReplaceAll(name, "logic", pluginName)
	}
	file := out + "/" + name
	if !isNeedCovered && isExists(file) {
		file += ".gen." + time.Now().Format("150405")
	}

	content = bytes.ReplaceAll(content, []byte("moduleNameExample"), []byte(moduleName))
	content = bytes.ReplaceAll(content, []byte("serverNameExample"), []byte(serverName))
	return os.WriteFile(file, content, 0666)
}

func isExists(path string) bool {
	_, err := os.Stat(path)
	if err != nil {
		return !os.IsNotExist(err)
	}
	return true
}
